\documentclass[a4paper]{article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}
\usepackage{charter}   % tipografia
\usepackage{graphicx}
\usepackage{makeidx}

\usepackage{float}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{amsfonts}
\usepackage{sectsty}
\usepackage{wrapfig}
\usepackage{listings}

\input{codesnippet}
\input{page.layout}
%\setcounter{secnumdepth}{2}
\usepackage{underscore}
\usepackage{caratula}
\usepackage{url}

\usepackage{color}
\usepackage{clrscode3e} % para el pseudocodigo




\begin{document}

\lstset{
  language=C++,
  backgroundcolor=\color{white},   % choose the background color
  basicstyle=\footnotesize,        % size of fonts used for the code
  breaklines=true,                 % automatic line breaking only at whitespace
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  keywordstyle=\color{blue},       % keyword style
  stringstyle=\color{mymauve},     % string literal style
}

\thispagestyle{empty}
\materia{Algoritmos y Estructuras de Datos III}
\submateria{Segundo Cuatrimestre de 2014}
\titulo{Trabajo Práctico I}
\subtitulo{Problemas de optimización}
\integrante{González Alba, Pablo}{476/10}{pablo.gonzalez.alba@gmail.com}
\integrante{Quiroz, Nicol\'as}{450/11}{nquiroz@dc.uba.ar}
\integrante{Vaghi, Agustín}{790/07}{vaghiagustin@gmail.com}
\integrante{Vuotto, Lucas}{385/12}{lvuotto@dc.uba.ar}

\maketitle
\newpage

\thispagestyle{empty}
\vfill
\begin{abstract}
    \textcolor{red}{\textbf{completar!}}
\end{abstract}

\thispagestyle{empty}
\vspace{3cm}
\tableofcontents
\newpage


%\normalsize
\newpage

\section{Objetivos generales}
  \textcolor{red}{\textbf{completar!}}

\newpage

\section{Plataforma de pruebas}
El testeo de los algoritmos implementados fue realizado, principalmente, en las máquinas del laboratorio 3 del DC. \newline
\begin{itemize}
  \item \textbf{Sistema Operativo:} Ubuntu Linux 12.04 x86_64, kernel 3.2.0-30-generic
  
  \item \textbf{Especificaciones del Software:} el código está implementado en C++. Utilizamos Bash y Ruby para los scripts.
  
  \item \textbf{Especificaciones del Hardware:} Intel(R) Core(TM) i5-2500K CPU @ 3.30GHz, 8GB de RAM.
\end{itemize}

\newpage

\section{Problema 1: Puentes sobre lava caliente}
\input{problema1}

\newpage

\section{Problema 2: Horizontes lejanos}
\input{problema2}

\newpage

\section{Problema 3: Biohazard}
\input{problema3}

\newpage
\section{Acerca de los tests}
Los casos aleatorios se generan mediante los scripts \verb|ejN.random.rb|, donde 
N es el número correspondiente al ejercicio. Estos scripts toman siempre dos parámetros, 
siendo el primero la semilla que utilizamos para generar números pseudoaleatorios, que 
por defecto toma el valor 0 si no es especificado y el segundo parámetro corresponde 
al tamaño de la entrada. 

Además de los tests con casos aleatorios, tenemos en cuenta los mejores y peores 
casos de cada algoritmo, fijando los valores adecuados de los parámetros para 
obtenerlos.

En cuanto a la metodología para medir el tiempo, utilizamos el archivo \verb|tiempo.h|, 
que define macros para contar la cantidad de ciclos de clock producidos entre dos instantes. 
Cada instancia se repite 25 veces para reducir el impacto de los \textit{outliers}, quedándonos 
con el valor mínimo en cada caso. Estos valores se vuelcan a un archivo \verb|info.n.dat|, que 
es utilizado luego para generar los gráficos mediante gnuplot.

Para correr los tests estáticos, se ejecuta \verb|make; make test| y para los 
casos aleatorios (utilizados para los gráficos), \verb|make; make plot|. 

Todos los archivos \verb|.cc| son compilados utilizando la optimización \verb|-O3|. 
  

\newpage

\section{Conclusiones}
    \textcolor{red}{\textbf{completar!}} \medskip
    escribir alguna conclusión para cerrar el tp y todos felices.

\newpage

\section{Apéndice: secciones relevantes del código}

\subsubsection{Problema 1}



\begin{lstlisting}
vector<unsigned int> cruzar_puente (unsigned int salto_maximo, vector<unsigned int>& puente) {
  vector<unsigned int> saltos;
  if (salto_maximo > puente.size()) {
    saltos.push_back(salto_maximo);
    return saltos;
  }
  if (!posible_cruzar(salto_maximo, puente)) {
    return saltos;
  }
  unsigned int salto_actual;
  unsigned int posicion_actual = 0;
  while (posicion_actual <= puente.size()) {
    salto_actual = salto_maximo;
    while (!puede_saltar(puente, posicion_actual + salto_actual - 1)) {
      salto_actual--;
    }
    posicion_actual += salto_actual;
    saltos.push_back(posicion_actual);
  }
  return saltos;
}
\end{lstlisting} 

\vspace*{0.5cm}

\begin{lstlisting}
bool posible_cruzar (unsigned int salto_maximo, vector<unsigned int>& puente) {
  unsigned int tablones_rotos_consecutivos = 0;
  for (unsigned int i = 0; i < puente.size(); i++) {
    if (puede_saltar(puente, i)) {
      tablones_rotos_consecutivos = 0;
    } else {
      tablones_rotos_consecutivos++;
    }
    if (tablones_rotos_consecutivos >= salto_maximo) {
      return false;
    }
  }
  return true;
}
\end{lstlisting}

\vspace*{0.5cm}

\begin{lstlisting}
bool puede_saltar (vector<unsigned int>& puente, unsigned int tablon) {
  return tablon >= puente.size() || puente[tablon] == 0;
}
\end{lstlisting}



\subsubsection{Problema 2}



\subsubsection{Problema 3}



\end{document}
