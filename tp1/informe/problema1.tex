\noindent
\textbf{1.1. Descripción del problema.}

\vspace*{0.3cm}

Este problema se trata de implementar un algoritmo que, de ser posible, 
\textbf{calcule la cantidad mínima de saltos} que debe dar un participante para poder cruzar un 
puente de cierto tamaño (fijo), el cual presenta \textbf{algunos de sus tablones rotos}. Estos se encuentran 
marcados y \textbf{deben ser evitados}, de otro modo, el participante fracasa en su intento y puede llegar a 
perder la vida. Cada uno de los participantes puede saltar una \textbf{determinada cantidad de tablones como máximo}. \medskip

El algoritmo debe decidir si dicha hazaña es posible, y de ser así, 
\textbf{especificar la cantidad de saltos a dar y a qué tablones hacerlo}. \medskip

Asumimos que tanto la \textbf{longitud del puente como la cantidad de saltos máximos por participante
son valores naturales}.

\vspace*{0.5cm}

\textbf{Ejemplos:}
\begin{itemize}
  \item Para un puente de 10 tablones y un participante capaz de saltar de a 3
  tablones como máximo, teniendo los tablones 1, 4, 6, 8 y 9 rotos, la salida podría ser: 
  primero saltar al tablón 3, luego al 5, luego al 7, luego al 10 y luego afuera del puente.
  \item Si en cambio, en el ejemplo anterior, el tablón 7 también estuviese roto,
  el algoritmo debe informarnos que, bajo esas condiciones, no es posible cruzar el puente.
  \item \textcolor{red}{\textbf{agregar un ejemplo mas con dibujitos y cosas lindas}}
\end{itemize}


\vspace*{0.75cm} \noindent



\noindent
\textbf{1.2. Desarrollo de la idea y pseudocódigo.}

\vspace*{0.3cm}

Para resolver este problema, propusimos un algoritmo de tipo \textit{greedy}, que en cada iteración
del mismo busca siempre saltar \textbf{la mayor cantidad posible de tablones}, siempre y cuando el 
tablón al que vamos a saltar esté sano. Caso contrario, se saltará al tablón anterior, y así sucesivamente.
Si retrocediendo de este modo se llega a la posición en la que se encuentran el competidor, el problema
\textbf{no tiene solución}.

\vspace*{0.5cm}


\begin{codebox}
\Procname{$\proc{cruzarPuente}(n,c,puente)$}
\li \Comment n: cantidad de tablones del puente puente es el vector 
\li \Comment c: cantidad de tablones máximos a saltar
\li \Comment puente: es el conjunto de tablones 
\li \Comment el primer tablón es el 1
\li $\id{solucion} \gets \emptyset$
\li \If $\id{c} > \id{n}$
\li     \Then 
            $\proc{agregar}(solucion, c)$
\li         \Return $\id{solucion}$
        \End
\li \If $\neg(\proc{esPosibleCruzar}(puente, c))$
\li     \Then 
            \Return $\emptyset$
        \End
\li $\id{posicionActual} \gets 0$
\li \While $\id{posicionActual} \leq \id{n}$
\li     \Do 
            $saltoActual \gets c$
\li         \While $\neg(\proc{puedeSaltar}(puente, posicionActual + saltoActual - 1))$
\li         \Do 
                $saltoActual \gets saltoActual - 1$
            \End
\li     $\id{posicionActual} \gets \id{posicionActual} + \id{saltoActual}$
\li     $\proc{agregar}(solucion, posicionActual)$    
        \End
\li \Return $\id{solucion}$
\end{codebox}      



\vspace*{0.5cm}



\begin{codebox}
\Procname{$\proc{puedeSaltar}(puente, tablon)$}
    \Return $\id{tablon} \geq \proc{tamanio}(puente) \lor \proc{estaSano}(puente[tablon])$
\end{codebox}



\vspace*{0.5cm}



\begin{codebox}
\Procname{$\proc{esPosibleCruzar}(puente, c)$}
\li \Comment c: cantidad de tablones máximos a saltar
\li $\id{tablonesRotosConsecutivos} \gets 0$
\li \For $i \gets 0$ \To $\proc{tamanio}(puente) - 1$
\li     \Do 
            \If $\proc{puedeSaltar}(puente, i)$
\li             \Then
                    $\id{tablonesRotosConsecutivos} \gets 0$
\li         \Else
\li             $\id{tablonesRotosConsecutivos} \gets \id{tablonesRotosConsecutivos} + 1$
            \End
\li         \If $\id{tablonesRotosConsecutivos} \geq c$
\li             \Then
                    \Return $\const{false}$
            \End
        \End
\li \Return $\const{true}$   
\end{codebox}



\vspace*{0.75cm} \noindent



\noindent
\textbf{1.3. Justificación de la resolución y demostración de correctitud.}

\vspace*{0.3cm}

Antes de comenzar con la demostración, diremos que una solución $S$ es de la forma $s \ t_1 \dots t_s$,
donde $s$ es la cantidad de saltos y $t_i$ es el $i$-ésimo tablón al cual saltar, y $S$ se considera
\textit{óptima} si $s$ es mínimo. También definiremos la relación entre soluciones $\sqsubseteq$, que
dadas soluciones $S = s \ t_1 \dots t_s$ y $H = h \ u_1 \dots u_h$, se define del seguiente modo:
\begin{align*}
  S \sqsubseteq H \iff s \leq h \wedge \bigwedge_{i=1}^s t_i = u_i
\end{align*}

Para demostrar que el algoritmo propuesto es correcto para la resolución de este problema, 
separaremos las entradas en casos y analizaremos cada uno por separado.

\begin{itemize}
  \item $c > n$: en este caso, la solución será de la forma $1 \ k$, con $k > n$. Como $c > n$, la 
  solución $1 \ c$ es una solución posible (y óptima).
  
  \item $c \leq n$: si la instancia no tiene solución, es porque hay $c$ o más tablones consecutivos rotos.
  En tal caso, la función \textsc{esPosibleCruzar} se encarga de decirnos si hay solución.
  
  \textcolor{red}{\textbf{hace falta DEMOSTRAR QUE esPosibleCruzar ES CORRECTO?!}}

\end{itemize}


\vspace*{0.75cm} \noindent



\noindent
\textbf{1.4. Análisis de complejidad.}

\vspace*{0.3cm}

Para el análisis de complejidad nos basaremos en el pseudocódigo del punto 1.2.

\begin{enumerate}
\item Todas las operaciones realizadas sobre el contenedor \verb|vector| de la \textit{STL} (size, push_back, empty y la creación de iteradores) 
toman tiempo constante $O(1)$.

\item Las asignaciones realizadas (11, 13, 15, 16 y 17) también se realizan en tiempo constante $O(1)$.

\item Si $c$ es mayor que $n$ (línea 6), retornamos el vector de soluciones que contiene la cantidad de saltos realizados (cero) y
el "tablón" $c$ hacia el cual saltamos. Como dijimos anteriormente, realizar estas operaciones sobre \verb|vector| 
toma tiempo constante $O(1)$.

\item En la línea 9, ejecutamos el condicional \verb|esPosibleCruzar(puente, c)|. La complejidad de esta función la
analizaremos luego, pero adelantamos que es lineal, $O(n)$.

\item En la línea 12 (tener en cuenta que en este caso vale $c \leq n$), en el peor caso ($c = 1$), realizamos $n$ iteraciones, 
pues recorremos el puente de a un tablón (siempre y cuando no haya tablones rotos, pues no tendría solución). Con $c \neq n$,  
en cualquier iteración podemos realizar a lo sumo $c$ retrocesos, pero en las siguientes esto es compensado, pues sabiendo que
hay solución, la metodología empleada no pregunta más de 1 vez el estado de un mismo tablón. Este procedimiento tiene como peores
casos los siguientes:
  \begin{itemize}
    \item $c = 1$, con todos los tablones sanos, de manera que haya que chequear todos los tablones del puente.
    
    \item $c = 2$, con un patrón de tablones sano - roto - sano, como se puede ver en la figura \textcolor{red}{\textbf{QUE DESPUES AGREGAMOS!}}
    
    \item $c = n$, con todos los tablones rotos salvo el primero, de manera que haya que chequear todos los tablones del puente. 
  \end{itemize}

\item La complejidad de \verb|esPosibleCruzar(puente, c)| (línea 9) es $O(n)$, pues en el peor caso recorre el puente entero.

\item La complejidad de \verb|puedeSaltar(puente, tablón)| es $O(1)$, pues obtenemos el tamaño del puente en tiempo constante 
mediante la función \verb|size| y preguntar si un tablón está sano ó no es constante.

\end{enumerate}

Por lo tanto, la \textbf{complejidad total} del algoritmo implementado para este problema es

\begin{align*}
  O(1) + O(1) + O(n) + O(n)*O(1) = \textit{\textbf{O(n)}}
\end{align*}



\vspace*{0.75cm} \noindent



\noindent
\textbf{1.5. Partes relevantes del código (hacer referencia al apéndice).}

\vspace*{0.3cm}

desarrollo.


\vspace*{0.75cm} \noindent



\noindent
\textbf{1.6. Experimentación.}

\vspace*{0.3cm}

desarrollo.
