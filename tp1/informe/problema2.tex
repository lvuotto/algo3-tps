\noindent
\textbf{2.1. Descripción del problema.}

\vspace*{0.3cm}

El objetivo de este problema es, dado un conjunto de edificios, representados
por la posición de sus paredes izquierda y derecha y su altura, representar el
contorno en el horizonte formado por la superposición de los mismos, excluyendo
las líneas internas. \medskip

\textbf{Ejemplos:}
\begin{itemize}
  \item Para un conjunto de 3 edificios, cuyas coordenadas son (4, 2, 11),
  (5, 4, 7) y (9, 5, 12), dónde la primer coordenada es la ubicación de la pared
  izquierda sobre el eje X, la segunda coordenada es la altura en el eje Y y la
  tercer coordenada es la ubicación de la pared derecha sobre el eje X, la
  solución debe ser 4 2 5 4 7 2 9 5 12 0
  \item Agregar un ejemplo más e imágenes
\end{itemize}


\vspace*{0.75cm} \noindent



\noindent
\textbf{2.2. Desarrollo de la idea y pseudocódigo.}

\vspace*{0.3cm}

La idea para resolver este problema consiste en tomar a los edificios por los 2
vértices que lo identifican (sus puntos con Y $\neq$ 0).

Recorriendo esos vértices en orden, los que correspondan a una pared izquierda
generarán un nuevo punto del horizonte si son más altos que el último punto y
los que correspondan a una pared derecha, si son el fin correspondiente de la
altura actual, generarán un punto en la intersección con la siguiente altura
más alta.

Para saber hasta dónde se debe bajar luego de un vértice de pared derecha, se
mantiene un multiconjunto de alturas, cada vértice de pared izquierda carga su
altura y los de pared derecha la eliminan.

\begin{codebox}
\Procname{$\proc{calcularHorizonte}(vertices)$}
\li \Comment vertices: vector de vértices
\li $\id{horizonte} \gets \emptyset$
\li $\id{alturas} \gets \emptyset$

\li $\proc{sort}(vertices)$

\li $\id{vertice} \gets \proc{primero}(vertices)$


\li $\proc{agregar}(horizonte, <vertice.x, vertice.y>)$
\li $\proc{agregar}(alturas, vertice.y)$


\li \While $\id{vertice} no es el ultimo$
      \Do
\li     \If $vertice.posicion_pared == izquierda$
          \Then
\li         \If $vertice.y > \proc{ultimo}(horizonte).y$
              \Then
\li             \If $vertice.x > \proc{ultimo}(horizonte).x$
                  \Then
\li                 $\proc{agregar}(horizonte, <vertice.x, vertice.y>)$
\li               \Else
\li                 $\proc{ultimo}(horizonte).y \gets vertice.y$
                 \End
              \End
\li         $\proc{agregar}(alturas, vertice.y)$
\li       \Else
\li         $\proc{quitar}(alturas, vertice.y)$
\li         \If $vertice.y > \proc{maximo}(alturas)$
              \Then
\li             $\proc{agregar}(horizonte, <vertice.x, maximo(alturas)>)$
              \End
          \End
\li     $\id{vertice} \gets \id{vertice} + 1$
      \End

\li \Return $\id{horizonte}$
\end{codebox}


\vspace*{0.75cm} \noindent


\noindent
\textbf{2.3. Justificación de la resolución y demostración de correctitud.}

\vspace*{0.3cm}

desarrollo



\vspace*{0.75cm} \noindent



\noindent
\textbf{2.4. Análisis de complejidad.}

\vspace*{0.3cm}



desarrollo


explicar lo del multiset y las complejidades y bla.


\vspace*{0.75cm} \noindent



\noindent
\textbf{2.5. Partes relevantes del código (hacer referencia al apéndice).}

\vspace*{0.3cm}

desarrollo.


\vspace*{0.75cm} \noindent



\noindent
\textbf{2.6. Experimentación.}

\vspace*{0.3cm}

desarrollo.
