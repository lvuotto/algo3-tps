\subsection{Descripción del problema.}

\vspace*{0.3cm}

El objetivo de este problema es, dado un conjunto de edificios representados
por la posición de sus paredes izquierda, derecha y su altura, representar el
contorno en el horizonte formado por la superposición de los mismos, excluyendo
las líneas internas. 

\vspace*{0.5cm}

\textbf{Ejemplos:}
\begin{itemize}
  \item Para un conjunto de 3 edificios, cuyas coordenadas son (4, 2, 11),
  (5, 4, 7) y (9, 5, 12), dónde la primer coordenada es la ubicación de la pared
  izquierda sobre el eje $X$, la segunda coordenada es la altura en el eje $Y$ y la
  tercer coordenada es la ubicación de la pared derecha sobre el eje $X$, la
  solución debe ser 4 2 5 4 7 2 9 5 12 0 (es única).
  
  \item \textcolor{red}{Agregar un ejemplo más y algún esquema/dibujo}
\end{itemize}



\subsection{Desarrollo de la idea y pseudocódigo.}

\vspace*{0.3cm}

El algoritmo propuesto para resolver este problema consiste en tomar a los edificios 
por los 2 vértices que lo identifican (sus puntos con $Y \neq 0$).

Recorriendo esos vértices en orden, los pertenecientes a una pared izquierda
generarán un nuevo punto en el horizonte si son más altos que el último punto agregado 
y los que correspondan a una pared derecha, si corresponden al final de la
altura actual, generarán un punto en la intersección con la siguiente altura mayor.

Para saber hasta dónde se debe bajar luego de un vértice de pared derecha, se
mantiene un multiconjunto de alturas. Cada vértice de pared izquierda carga su
altura y los de pared derecha la eliminan.

\begin{codebox}
\Procname{$\proc{calcularHorizonte}(vertices)$}
\li \Comment vertices: vector de vértices
\li $\id{horizonte} \gets \emptyset$
\li $\id{alturas} \gets \emptyset$
\li $\proc{sort}(vertices)$
\li $\id{vertice} \gets \proc{primero}(vertices)$
\li $\proc{agregar}(horizonte, <vertice.x, vertice.y>)$
\li $\proc{agregar}(alturas, vertice.y)$
\li \While $\id{vertice} no es el ultimo$
      \Do
\li     \If $vertice.posicion_pared == izquierda$
          \Then
\li         \If $vertice.y > \proc{ultimo}(horizonte).y$
              \Then
\li             \If $vertice.x > \proc{ultimo}(horizonte).x$
                  \Then
\li                 $\proc{agregar}(horizonte, <vertice.x, vertice.y>)$
\li               \Else
\li                 $\proc{ultimo}(horizonte).y \gets vertice.y$
                 \End
              \End
\li         $\proc{agregar}(alturas, vertice.y)$
\li       \Else
\li         $\proc{quitar}(alturas, vertice.y)$
\li         \If $vertice.y > \proc{maximo}(alturas)$
              \Then
\li             $\proc{agregar}(horizonte, <vertice.x, maximo(alturas)>)$
              \End
          \End
\li     $\id{vertice} \gets \id{vertice} + 1$
      \End
\li \Return $\id{horizonte}$
\end{codebox}



\subsection{Justificación de la resolución y demostración de correctitud.}

\vspace*{0.3cm}


Dado un conjunto de edificios $E$, la solución será un conjunto de puntos
$S_E = \{p \in \mathbb{Z}^2 : \exists e \in E / (p_x = e_i \land p_y = e_y) \land
p \notin T_E\} \cup \{p \in \mathbb{Z}^2 : \exists e \in E / (p_x = e_d \land p
\notin T_E) \land p_y = \max{\{e_y : e \in E \land e_i \leq p_x < e_d\} \cup \{0\}}\}$,
donde $T_E = \{p \in \mathbb{Z}^2 : \exists e \in E / (e_i \leq p_x \leq e_d \land p_y < e_y)\}$

Para demostrar la correctitud de este algoritmo, veremos que cumple con la 
definición dada más arriba. 

Primero, el algoritmo recorre en orden todos los puntos de los edificios. 
(completar con las lineas correspondientes del pseudocodigo)
Luego, para cada punto, chequea si cumple las condiciones necesarias para ser 
incorporado a la solución, es decir:

\begin{itemize}
  \item si es un vértice izquierdo del edificio, que el último punto cargado en
  la solución no se encuentre por encima de éste. Además, si la coordenada $x$ 
  del último punto cargado es igual a la de éste, se reemplaza el último punto 
  agregado por el actual.
  
  \item si es un vértice derecho, dado el conjunto de alturas, si la altura 
  máxima es menor a la altura del punto, se agrega a la solución el punto con 
  coordenada $x = x_{vertice}$ e $y = max(conj(altura))$
\end{itemize}



\subsection{Análisis de complejidad.}

\vspace*{0.3cm}

Respecto de las operaciones utilizadas de \verb|vector|, \verb|size| $\in O(1)$,
\verb|back| $\in O(1)$, \verb|resize| $\in O(n)$, \verb|push_back| $\in O(1)$, 
\verb|begin| $\in O(1)$, \verb|end| $\in O(1)$ y \verb|operator[]| $\in O(1)$.

\noindent
En \verb|Vertice|, el constructor y el \verb|operator<| son $O(1)$. También 
tiene complejidad constante el constructor de \verb|Punto|.

\noindent
En las operaciones utilizadas de \verb|multiset|, \verb|insert| $\in O(\log n)$, 
\verb|erase| $\in O(1)$, \verb|find| $\in O(\log n)$, \verb|empty| $\in O(1)$ y 
\verb|rbegin| $\in O(1)$.

\noindent
Sobre los iteradores, se realizan las operaciones \verb|++| y \verb|*|, ambas
con complejidad constante.

\noindent
Se implementó la función \verb|maximo|, que dado un \verb|multiset|, devuelve 
el mayor de sus elementos, o 0 si el \verb|multiset| está vacío. Dicha función
tiene complejidad constante, pues \verb|empty| $\in O(1)$ y \verb|rbegin| $\in O(1)$.

\noindent
El algoritmo \verb|sort| utilizado tiene complejidad $O(n \log n)$.

\noindent
Se itera sobre cada vértice y en cada iteración, en el peor de los casos, se 
realiza una operación de complejidad logarítmica. Al tener $2n$ vértices, esto se
traduce en $O(n \log n)$.


\textcolor{red}{\textbf{FALTA DESCRIBIR BIEN EL ALGORITMO, $i.e.$, EL ÚLTIMO PÁRRAFO}}



\subsection{Partes relevantes del código (hacer referencia al apéndice).}

\vspace*{0.3cm}

desarrollo.



\subsection{Experimentación y gráficos.}

\vspace*{0.3cm}

desarrollo.
