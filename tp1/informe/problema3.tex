\subsection{3.1. Descripción del problema.}

\vspace*{0.3cm}

desarrollo.

\vspace*{0.75cm} \noindent

El objetivo de este problema es, distribuir N productos en C camiones, minimizando
C. Al combinarse los elementos se obtienen distintintos niveles de peligrosidad.
Para minimizar C, se debe tener en cuenta que contamos con un umbral de peligrosidad
M, el cual no debe ser superado por la suma de los niveles de peligrosidad de los
elementos que contiene.

\textbf{Ejemplos}
\begin{itemize}
  \item Dado $M = 7$ y 4 productos $p_1, p_2, p_3$ y $p_4$, con una relación
  de peligrosidad $h_{1,2} = 5, h_{1,3} = 3, h_{1,4} = 4, h_{2,3} = 6, h_{2,4} =
  3$ y $h_{3,4} = 5$, la solución óptima es utilizar 2 camiones, el primero
  transportando $p_1$ y $p_3$, y el segundo transportando $p_2$ y $p_4$.
  \item Agregar otro ejemplo.
\end{itemize}





\subsection{3.2. Desarrollo de la idea y pseudocódigo.}

Para resovler el problema, empezamos con un camión e intentamos ubicar todos los
elementos en el mismo. De no ser posible, se agrega otro camión y se vuelve a
intentar todas las combinaciones de elementos en los mismos. Si no caben los
elementos en un solo camión, se agrega un camión más y se vuelve a empezar.

Se repite el proceso hasta encontrar una cantidad de camiones que pueda transportar
todos los elementos. Por la estrategia planteada para el problema, la solución
encontrada será una solución óptima.

Para facilitar los cálculos y permitir mejores podas, se utilizará una estructura
adicional que contendrá, para cada elemento, dado un camión, la peligrosidad que
pasaría a tener dicho camión si se agregase tal elemento. Esta estructura se
actualizará cada vez que se agregue un elemento a algún camión. 

biohazard(elementos, maximaPeligrosidad) {
  camiones = []
  agregar(camiones, camion)
  
  while (!backtracking(camiones, elementos, aux)) {
    agregar(camiones, camion)
  }
  
  return camiones
}

booleano backtracking(camiones: conjunto, elementos: conjunto, aux: auxiliar)
  si vacio(elementos)
    retornar verdadero
  
  elemento = dameUno(elementos)
  elementos = elementos - elemento
  
  para camion en camiones
    si entra(elemento, camion, aux)
      agregar(camion, elemento)
      actualizar(aux)
      si backtracking(camiones, elementos, aux)
        retornar verdadero
      sino
        borrar(camion, elemento)
  fin para
  
  retornar falso


 
\vspace*{0.3cm}

desarrollo.


\vspace*{0.75cm} \noindent





\subsection{3.3. Justificación de la resolución y demostración de correctitud.}

\vspace*{0.3cm}


opcional


\vspace*{0.75cm} \noindent





\subsection{3.4. Análisis de complejidad.}

\vspace*{0.3cm}


La función \verb|backtracking| es llamada desde la función \verb|biohazard|, en
el peor de los casos, tantas veces como elementos haya para insertar en los camiones.
Una vez que se comienza a hacer la recursión, por cada camión que podemos utilizar,
se vuelve a hacer con un elemento menos. La recursión finaliza en el momento en 
el que se la invoca con un conjunto vacío de elementos. Como la cantidad de 
elementos siempre disminuye en 1 con cada llamado recursivo, en $n$ llamados se
corta la recurrencia.

Por lo tanto, en el peor caso, cuando todos los elementos tengan que ir en un 
camión diferente se requerirán $n$ camiones, con $n$ llamadas recursivas con 
$n - 1$ elementos que a su vez harán $n$ llamadas recursivas cada uno, hasta que
la cantidad de elementos sea 0, dando una complejidad de $O(n^n)$.

\textbf{FALTA:}

entra: O(1) + O(calcularPeligrosidad)

calcularPeligrosidad: ¿?

agregarElemento: ¿?

eliminarElemento: log n + O(calcularPeligrosidad)

agregar las complejidades de las funciones usadas de vector, set y camion

\vspace*{0.75cm} \noindent





\subsection{3.5. Partes relevantes del código (hacer referencia al apéndice).}

\vspace*{0.3cm}

desarrollo.


\vspace*{0.75cm} \noindent





\subsection{3.6. Experimentación y gráficos.}

\vspace*{0.3cm}

desarrollo.
