S\subsection{Descripción del problema.}

\vspace*{0.3cm}

desarrollo.

\vspace*{0.75cm} \noindent

Este problema trata sobre distribuir $N$ productos en $C$ camiones, minimizando
el valor de $C$. Al combinarse los elementos, se obtienen distintos niveles de peligrosidad.
Para minimizar $C$, se debe tener en cuenta que contamos con un umbral de peligrosidad
$M$, \textbf{el cual no debe ser superado por la suma de los niveles de peligrosidad de los
elementos que contiene}.

\vspace*{0.5cm}

\textbf{Ejemplos:}
\begin{itemize}
  \item Dado $M = 7$ y 4 productos $p_1, p_2, p_3$ y $p_4$, con una relación
  de peligrosidad $h_{1,2} = 5, h_{1,3} = 3, h_{1,4} = 4, h_{2,3} = 6, h_{2,4} =
  3$ y $h_{3,4} = 5$, la solución óptima es utilizar 2 camiones, el primero
  transportando $p_1$ y $p_3$, y el segundo transportando $p_2$ y $p_4$.
  
  \item \textcolor{red}{Agregar otro ejemplo.}
\end{itemize}



\subsection{Desarrollo de la idea y pseudocódigo.}

Para resovler el problema, empezamos utilizando un solo camión e intentamos ubicar 
todos los elementos en el mismo. De no ser posible, se agrega otro camión y se vuelven 
a intentar todas las combinaciones de elementos en los mismos. Si siguen sin caber los
elementos, se agrega un camión más y se vuelve a empezar.

Este proceso continúa hasta encontrar una cierta cantidad de camiones, capaz de 
transportar todos los elementos. Por la estrategia planteada para el problema, 
\textbf{la solución encontrada será una solución óptima}.

\vspace*{0.5cm}


\begin{codebox}
\Procname{$\proc{biohazard}(elementos, maximaPeligrosidad)$}
\li $\id{camiones} \gets []$
\li $\proc{agregar}(camiones, camion)$
\li \While $\neg(\proc{backtracking}(camiones, elementos))$
\li     \Do
            $\proc{agregar}(camiones, camion)$
        \End
\li \Return $\id{camiones}$
\end{codebox}


\vspace*{0.5cm} 


\begin{codebox}
\Procname{$\proc{backtracking}(camiones, elementos)$}
\li \If $\proc{vacio?}(elementos)$
\li     \Then
            \Return $\const{true}$
        \End
\li $\id{elemento} \gets \proc{dameUno}(elementos)$
\li $\id{elementos} \gets elementos \setminus \{elemento\}$
\li \For $camion \in camiones$
\li     \Do
            \If $\proc{entra?}(elemento, camion)$
\li             \Then
                    $\proc{agregar}(camion, elemento)$
\li                 \If $\proc{backtracking}(camiones, elementos)$
                        \Then
\li                         \Return $\const{true}$
\li                 \Else
\li                     $\proc{borrar}(camion, elemento)$
                    \End    
            \End
        \End
\li \Return $\const{false}$
\end{codebox}



\subsection{Justificación de la resolución y demostración de correctitud.}

\vspace*{0.3cm}


opcional


\vspace*{0.75cm} \noindent



\subsection{Análisis de complejidad.}

\vspace*{0.3cm}


La función \verb|backtracking| es llamada desde la función \verb|biohazard|, en
el peor de los casos, tantas veces como elementos haya para insertar en los camiones.
Una vez que se comienza a hacer la recursión, por cada camión que podemos utilizar,
se vuelve a hacer con un elemento menos. La recursión finaliza en el momento en 
el que se la invoca con un conjunto vacío de elementos. Como la cantidad de 
elementos siempre disminuye en 1 con cada llamado recursivo, en $n$ llamados se
corta la recurrencia.

Por lo tanto, en el peor caso, cuando todos los elementos tengan que ir en un 
camión diferente se requerirán $n$ camiones, con $n$ llamadas recursivas con 
$n - 1$ elementos que a su vez harán $n$ llamadas recursivas cada uno, hasta que
la cantidad de elementos sea 0, dando una complejidad de $O(n^n)$.

\textbf{FALTA:}

entra: O(1) + O(calcularPeligrosidad)

calcularPeligrosidad: ¿?

agregarElemento: ¿?

eliminarElemento: log n + O(calcularPeligrosidad)

agregar las complejidades de las funciones usadas de vector, set y camion

\vspace*{0.75cm} \noindent



\subsection{Experimentación y gráficos.}

\vspace*{0.3cm}

desarrollo.
