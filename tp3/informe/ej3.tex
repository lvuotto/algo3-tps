\subsection{Descripción del algoritmo implementado.}
\vspace*{0.3cm}

\textcolor{red}{\textbf{completar!}}

Con la idea de que evitando las aristas más pesadas se puede reducir el peso
total, el algoritmo consiste en ordenar las aristas por peso en orden
descendente. Luego, por cada arista, se agregan sus 2 nodos a los conjuntos que
resulten en el menor peso total.

Pseudo:
goloso(grafo, cantidadDeConjuntos) {
	particion = Particion(grafo, cantidadDeConjuntos)

	aristas = ordenarPorPeso(aristas(grafo))

	por cada arista en aristas {
		agregarAlDeMenosPeso(particion, vertice1(arista))
		agregarAlDeMenosPeso(particion, vertice2(arista))
	}

	return particion
}

agregarAlDeMenosPeso(particion, vertice) {
	si contiene(particion, vertice)
		return

	minConjunto = primero(conjuntos(particion))
	minCosto = costo(minConjunto, vertice)

	por cada conjunto en conjuntos(particion) {
		si costo(conjunto, vertice) < minCosto {
			minConjunto = conjunto
			minCosto = costo(conjunto, vertice)
		}
	}
}

costo(conjunto, nuevoVertice) {
	costo = 0
	por cada vertice en conjunto {
		costo += costo(vertice, nuevoVertice)
	}

	return costo
}


\newpage
\subsection{Análisis de complejidad en el peor caso.}
\vspace*{0.3cm}

\textcolor{red}{\textbf{completar!}}

n = |vertices|
m = |aristas|
k = |conjuntos|
Se ordenan las aristas. O(m * log(m)).
Se recorren todas y por cada una se calcula el costo de agregarla a cada
conjunto. Calcular el costo en un conjunto es O(n), porque se comparan todos
los vértices, lo que llevaría a pensar que es O(k * n), pero como cada
conjunto tiene vértices distintos que los otros, en total nunca se hacen más
de n comparaciones de vértices. Es decir, O(k + n).

Total: O(m * log(m) + m * (k + n))

(Todas las otras cosas que se hacen son O(1))



\newpage
\subsection{Instancias de k-PMP para las cuales la heurística no proporciona
            una solución óptima.}
\vspace*{0.3cm}
\textcolor{red}{\textbf{completar!}}

Como el algoritmo intenta deshacerse primero de las aristas más pesadas, el
peor caso es cuando el problema lo dan muchas aristas de poco peso.

Esta situación se puede generar de la siguiente forma: si se quiere resolver el
problema para $k$ conjuntos, el grafo debe tener 2 tipos de vértices: $k$
vértices, todos ellos adyacentes entre sí, con peso $\omega > 0$, y luego $h$
vértices, cada uno adyacente únicamente a los primeros $k$ vértices, con un
peso $\sigma$, $0 < \sigma < \omega$.  Por como se comporta el algoritmo, las
aristas que unen a los primeros $k$ vértices se ubicarán primero, repartiendo
así los $k$ vértices en conjuntos distintos. Luego, de cualquier forma que se
agreguen los siguientes vértices, cada uno generará un costo $\sigma$, siendo
el peso total $h \sigma$. Sin embargo, poniendo 2 de los primeros $k$ vértices
en un mismo conjunto y los otros $h$ vértices en el conjunto vacío restante,
se obtendrá un peso $\omega$, pues los $h$ vértices con aristas de peso
$\sigma$ no son adyacentes y suman peso $0$. De esta forma, con $\omega$ y
$\sigma$ fijos, a partir de un $h_0$, $h \sigma > \omega$. Luego, aumentando
$h$, se obtiene una familia de grafos para la cual la heurística falla en dar
una buena aproximación de la solución.


\newpage \subsection{Experimentación y gráficos.}
\vspace*{0.3cm}

\textcolor{red}{\textbf{completar!}}
