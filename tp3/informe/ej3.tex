\subsection{Descripción del algoritmo implementado.}
\vspace*{0.3cm}

\textcolor{red}{\textbf{completar!}}

Con la idea de que evitando las aristas más pesadas se puede reducir el peso
total, el algoritmo consiste en ordenar las aristas por peso en orden
descendente. Luego, por cada arista, se agregan sus 2 nodos a los conjuntos que
resulten en el menor peso total.

Pseudo:
goloso(grafo, cantidadDeConjuntos) {
	particion = Particion(grafo, cantidadDeConjuntos)

	aristas = ordenarPorPeso(aristas(grafo))

	por cada arista en aristas {
		agregarAlDeMenosPeso(particion, vertice1(arista))
		agregarAlDeMenosPeso(particion, vertice2(arista))
	}

	return particion
}

agregarAlDeMenosPeso(particion, vertice) {
	si contiene(particion, vertice)
		return

	minConjunto = primero(conjuntos(particion))
	minCosto = costo(minConjunto, vertice)

	por cada conjunto en conjuntos(particion) {
		si costo(conjunto, vertice) < minCosto {
			minConjunto = conjunto
			minCosto = costo(conjunto, vertice)
		}
	}
}

costo(conjunto, nuevoVertice) {
	costo = 0
	por cada vertice en conjunto {
		costo += costo(vertice, nuevoVertice)
	}

	return costo
}


\newpage
\subsection{Análisis de complejidad en el peor caso.}
\vspace*{0.3cm}

Llamemos:
$n$ = |vertices|
$m$ = |aristas|
$k$ = |conjuntos|

\vspace*{0.3cm}

La función $costo$ recorre todos los vértices de un conjunto y calcula el
costo de la adyacencia de 2 vértices (si existiese), al usar una matriz de
adyacencia para representar el grafo, esto es $O(1)$, por lo que la función
tiene orden $O(cantidad de vértices en el conjunto)$

\vspace*{0.3cm}

La función $agregarAlDeMenosPeso$ primero se fija en $O(1)$ si un vértice
pertenece al nodo. De no hacerlo, recorre todos los conjuntos, calculando en
cada uno el $costo$ de agregar el vértice.

Recorrer todos los conjuntos es $O(k)$ y calcular el costo entonces es:
$\sum_{i}^{k} cantidad de vértices del conjunto i$.

Como los conjuntos son disjuntos (por ser una partición), entre todos los
conjuntos va a haber a lo sumo $n$ vértices, por lo tanto esa sumatoria en
realidad es $O(n)$.

Finalmente el orden total es $O(k + n)$

\vspace*{0.3cm}


Primero se crea una partición con $k$ conjuntos, que toma un tiempo $O(k)$.

Luego se ordenan las aristas, esto tiene orden $O(m * log(m))$.

Posteriormente se entra en un ciclo que recorre todas las aristas, que toma
$O(m)$ multiplicado por el tiempo que tome el ciclo.

El ciclo realiza 2 veces $agregarAlDeMenosPeso$ que ya vimos toma $O(k + n)$,
entonces el ciclo en total tiene orden $O(m * (k + n))$

Por lo tanto, el costo total tiene orden: $O(k + m * log(m) + m * (k + n))$.

Para los casos interesantes, cuando $k < n$ (de lo contrario se puede poner un
nodo en cada uno para obtener peso 0) y, teniendo en cuenta que $O(m) = O(n^2)$,
la complejidad también pertenece a $O(n^3)$.

\newpage
\subsection{Instancias de k-PMP para las cuales la heurística no proporciona
            una solución óptima.}
\vspace*{0.3cm}
\textcolor{red}{\textbf{completar!}}

Como el algoritmo intenta deshacerse primero de las aristas más pesadas, el
peor caso es cuando el problema lo dan muchas aristas de poco peso.

Esta situación se puede generar de la siguiente forma: si se quiere resolver el
problema para $k$ conjuntos, el grafo debe tener 2 tipos de vértices: $k$
vértices, todos ellos adyacentes entre sí, con peso $\omega > 0$, y luego $h$
vértices, cada uno adyacente únicamente a los primeros $k$ vértices, con un
peso $\sigma$, $0 < \sigma < \omega$.  Por como se comporta el algoritmo, las
aristas que unen a los primeros $k$ vértices se ubicarán primero, repartiendo
así los $k$ vértices en conjuntos distintos. Luego, de cualquier forma que se
agreguen los siguientes vértices, cada uno generará un costo $\sigma$, siendo
el peso total $h \sigma$. Sin embargo, poniendo 2 de los primeros $k$ vértices
en un mismo conjunto y los otros $h$ vértices en el conjunto vacío restante,
se obtendrá un peso $\omega$, pues los $h$ vértices con aristas de peso
$\sigma$ no son adyacentes y suman peso $0$. De esta forma, con $\omega$ y
$\sigma$ fijos, a partir de un $h_0$, $h \sigma > \omega$. Luego, aumentando
$h$, se obtiene una familia de grafos para la cual la heurística falla en dar
una buena aproximación de la solución.


\newpage \subsection{Experimentación y gráficos.}
\vspace*{0.3cm}

\textcolor{red}{\textbf{completar!}}
